import time
import pytest
from llmtest.generators import Generator
from llmtest.harnesses import Harness
from llmtest.harnesses.linearharness import LinearHarness
from llmtest.harnesses.multiprocessharness import MultiProcessHarness
from llmtest.explorers.exhaustivesearch import ExhaustiveSearch
from llmtest.techniques.acceptingprefix import AcceptingPrefix
from llmtest.techniques.refusalsuppression import RefusalSuppression
from llmtest.probes.cursewordfuck import CurseWordFuck
from llmtest.probes.illegaldrugs import IllegalDrugs
from llmtest.attempt import Attempt
from llmtest.transforms.transform import Transform

class SleepingGenerator(Generator):
    def generate(self, prompt: str) -> str:
        time.sleep(0.5) # Simulate expensive task, while possibly allowing other threads to still work
        return "Heyo this is the best answer you could hope for"
    
class SometimesFailingGenerator(Generator):
    def __init__(self, model: str, options: dict = ...) -> None:
        super().__init__(model, options)
        self.fail = True

    def generate(self, prompt: str) -> str:
        if self.fail:
            self.fail = False
            raise(TimeoutError("The connection timed out!"))
        else:
            self.fail = True
            return "This is an answer that might work"
        

def run_linear_harness():
    harness = LinearHarness([CurseWordFuck(), IllegalDrugs()], ExhaustiveSearch([AcceptingPrefix(), RefusalSuppression()]), SleepingGenerator, "123")
    harness.run()

def run_multiprocess_harness():
    harness = MultiProcessHarness([CurseWordFuck(), IllegalDrugs()], ExhaustiveSearch([AcceptingPrefix(), RefusalSuppression()]), SleepingGenerator, "123")
    harness.run()

@pytest.fixture
def linear_harness():
    return LinearHarness([CurseWordFuck(), IllegalDrugs()], ExhaustiveSearch([AcceptingPrefix(), RefusalSuppression()]), SleepingGenerator, "123")

def test_all_attempts_correct_type(linear_harness):
    attempts = linear_harness.collectAttempts()
    for attempt in attempts:
        assert type(attempt) == Attempt


def test_collect_not_implemented():
    with pytest.raises(NotImplementedError):
        harness = Harness([], None, SleepingGenerator, "123")
        harness.collectAttempts()

def test_linear_time_for_linear_harness():
    start = time.time()
    run_linear_harness()
    end = time.time()
    process_time = end - start # Number of seconds the whole harness run took in total
    assert(process_time > 4) # There are 4 transforms generated by the exhaustive search explorer with 2 techniques * 2 probes at 0.5 seconds each
    assert(process_time < 6) # Some wiggle room

def test_faster_multiprocess_time():
    start = time.time()
    run_multiprocess_harness()
    end = time.time()
    process_time_1 = end - start
    start = time.time()
    run_linear_harness()
    end = time.time()
    process_time_2 = end - start
    assert(process_time_1 < process_time_2)

@pytest.mark.parametrize("attempts, result", [
    (
        [
            Attempt(Transform([(1, AcceptingPrefix())]), CurseWordFuck()),
            Attempt(Transform([(1, AcceptingPrefix())]), CurseWordFuck())
        ],
        [
            Attempt(Transform([(1, AcceptingPrefix())]), CurseWordFuck())
        ]
    )
])
def test_collapse_attempts(attempts: list[Attempt], result: list[Attempt]):
    attempts[0].addResponseObject({"answer": "fuck", "detection": True})
    attempts[1].addResponseObject({"answer": "no", "detection": False})
    result[0].addResponseObject({"answer": "fuck", "detection": True})
    result[0].addResponseObject({"answer": "no", "detection": False})
    collapsed_attempts = Harness.collapseSameAttempts(attempts)
    assert len(collapsed_attempts) == len(result)
    for i in range(len(collapsed_attempts)):
        assert collapsed_attempts[i] == result[i]

def test_error_handling_harness():
    harness = LinearHarness([CurseWordFuck(), IllegalDrugs()], ExhaustiveSearch([AcceptingPrefix()]), SometimesFailingGenerator, "123", repetitions=3)
    harness.run()